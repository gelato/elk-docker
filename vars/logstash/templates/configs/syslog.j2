input {
    rabbitmq {
      host => "{{ rabbitmq_endpoint }}"
      subscription_retry_interval_seconds => 5
      ack => true
      arguments => { "x-ha-policy" => "all" }
      auto_delete => false
      automatic_recovery => true
      codec => "json"
      connect_retry_interval => 1
      connection_timeout => {{ logstash_rabbitmq_connection_timeout }}
      durable => {{ logstash_exchange_durable | lower() }}
      exchange => "{{ logstash_exchange_name }}"
      heartbeat => {{ logstash_rabbitmq_heartbeat }}
      key => "logstash-syslog"
      metadata_enabled => "{{ logstash_rabbitmq_send_metadata | lower() }}"
      user => "{{ logstash_rabbitmq_output_user }}"
      password => "{{ logstash_rabbitmq_output_password }}"
      queue => "logstash-syslog"
      threads => "{{ logstash_rabbitmq_threads }}"
      prefetch_count => "{{ logstash_prefetch_count }}"
      vhost => "{{ logstash_rabbitmq_vhost }}"
    }
}

filter {
  if [type] == "linux-syslog" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:process_state_change_time} %{HOSTNAME} /etc/init.d/%{WORD:init_script}: %{WORD:process} %{WORD:process_state}" }
      match => { "message" => "^%{SYSLOGTIMESTAMP:syslog_timestamp}\s*%{SYSLOGHOST:syslog_hostname}\s*(%{PROG:syslog_program})?\s*(:?\[%{POSINT:syslog_pid}\])?:?\s*%{GREEDYDATA:syslog_message}[a-z]*\s*$" }
      add_tag => "syslog_everything"
      keep_empty_captures => "true"
      tag_on_failure => "logstash_syslog_parsefailure"
      overwrite => [ "message" ]
    }
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }
  }
}
