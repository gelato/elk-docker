input {
    rabbitmq {
      host => "{{ rabbitmq_endpoint }}"
      subscription_retry_interval_seconds => 5
      ack => "true"
      arguments => { "x-ha-policy" => "all" }
      auto_delete => "false"
      automatic_recovery => "true"
      codec => "json"
      connect_retry_interval => 1
      connection_timeout => 10000
      durable => "true"
      exchange => "logstash_reciever"
      heartbeat => 1
      key => "logstash-authlog"
      metadata_enabled => "{{ logstash_rabbitmq_send_metadata | lower() }}"
      user => "{{ logstash_rabbitmq_output_user }}"
      password => "{{ logstash_rabbitmq_output_password }}"
      queue => "logstash-authlog"
      threads => 3
      prefetch_count => 50
      vhost => "logstash"
    }
}

filter {
    if [message] =~ /.*sshd.*\s*/ and [type] == "linux-authlog" {
        grok {
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? %{WORD:shh_result}*\s%{WORD:auth_method}\s*for\s*%{WORD:for_username}\s*from\s*%{IP:src_ip}\s*port\s*%{INT:src_port}\s*%{WORD:protocol}:?\s*%{GREEDYDATA:ssh_key}?" }
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? Invalid user %{WORD:invalid_username} from %{IP:src_ip}\s*" }
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? %{WORD:request}:? invalid user %{WORD:invalid_user} %{GREEDYDATA:invalid_user_message}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? Failed password for (invalid user |)%{USERNAME:failedpass_username} from %{IP:src_ip} port %{BASE10NUM:port} %{WORD:protocol}\s*"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? Received %{WORD:ssh_event} from %{IP:src_ip}: %{BASE10NUM:port}: %{GREEDYDATA}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? %{WORD:method}:?\(%{DATA:pam_method}\):?%{GREEDYDATA:ssh_pam_message}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? Connection %{WORD:connection_state} by %{IP:src_ip} %{GREEDYDATA:ssh_conn_message}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? PAM %{BASE10NUM:failure_count} more authentication (failure|failures);? %{GREEDYDATA:authfail_message}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? error: %{GREEDYDATA}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? Server listening on %{IP:ssh_listen_ip} port %{BASE10NUM:ssh_listen_port}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? Received signal %{BASE10NUM:recieved_interrupt_signal};?"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sshd\[%{BASE10NUM}\]:? Did not receive identification string from %{IP:no_idstring_from_ip}"}
            tag_on_failure => "logstash_ssh_parsefailure"
            add_tag => "logstash_ssh"
            }
        date {
           match => [ "timestamp", "MMM dd HH:mm:ss"]
           timezone => "Europe/Simferopol"
           }
         geoip {
          source => "src_ip"
          target => "geoip"
          add_tag => [ "authlog-geoip" ]
          }
        date {
           match => [ "timestamp" , "MMM dd HH:mm:ss" ]
           remove_field => [ "timestamp" ]
          }
    } else if [message] =~ /.*sudo.*\s*/ and [type] == "linux-authlog" {
        grok {
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sudo:?\s*%{WORD:sudoer}\s?:?\s?TTY=%{NOTSPACE:sudoer_tty}\s*;?\s*PWD=%{NOTSPACE:pwd}\s*;?\s*USER=%{NOTSPACE:sudo_to_user}\s*;?\s*COMMAND=%{GREEDYDATA:command}"}
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} sudo:?\s*%{GREEDYDATA:pam_message}"}
            tag_on_failure => "logstash_pam_parsefailure"
            add_tag => "logstash_pam"
        }
    } else if [type] == "linux-authlog" {
        grok {
            match => {"message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:host_target} %{SYSLOGPROG}:?\s*%{GREEDYDATA:authlog_message}"}
            add_tag => "logstash_auth_log"
            tag_on_failure => "logstash_authlog_parsefailure"
        }
    }
    geoip {
                source => "src_ip"
                target => "geoip"
                add_tag => [ "authlog-geoip" ]
                }
}
